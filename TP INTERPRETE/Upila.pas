unit UPila;

interface

uses Tipos,MATRIZ,Automatas,TABLA1,TRADUCTOR,CRT;

PROCEDURE CREARPILA(VAR P:PILAT);
PROCEDURE APILAR (VAR P:PILAT;ELEM:VariablesTerminales;APUNTADOR:PARBOL);
PROCEDURE DESAPILAR (VAR P:PILAT;VAR ELEM:VariablesTerminales;VAR APUNTADOR:PARBOL);
FUNCTION PILA_LLENA (VAR P:PILAT): BOOLEAN;
FUNCTION PILA_VACIA (VAR P:PILAT): BOOLEAN;
PROCEDURE PILAA;

implementation

PROCEDURE CREARPILA(VAR P:PILAt);
BEGIN
	P.TOPE:=0;
END;


PROCEDURE APILAR (VAR P:PILAT;ELEM:VariablesTerminales;APUNTADOR:PARBOL);
BEGIN
	P.TOPE:=P.TOPE+1;
	P.ELEM[P.TOPE].VOT:=ELEM;
	P.ELEM[P.TOPE].APUNTA:=APUNTADOR;
END;

PROCEDURE DESAPILAR (VAR P:PILAT;VAR ELEM:VariablesTerminales;VAR APUNTADOR:PARBOL);
BEGIN
	ELEM:=P.ELEM[P.TOPE].VOT;
	APUNTADOR:=P.ELEM[P.TOPE].APUNTA;
	P.TOPE:=P.TOPE-1;
END;


FUNCTION PILA_LLENA (VAR P:PILAT): BOOLEAN;
BEGIN
	PILA_LLENA:= P.TOPE=MAX;
END;


FUNCTION PILA_VACIA (VAR P:PILAT): BOOLEAN;
BEGIN
	PILA_VACIA:= P.TOPE=0;
END;


PROCEDURE CREARNODO(VAR ARBOL:PARBOL;VOT:VARIABLESTERMINALES;LEXEMA:STRING);
BEGIN
	NEW(ARBOL);
	ARBOL^.VOT:=VOT;
	ARBOL^.LEXEMA:=LEXEMA;
	ARBOL^.CANTIDADHIJOS:=0;
END;


PROCEDURE AGREGARHIJO(VAR PADRE:PARBOL;HIJO:PARBOL);
BEGIN
	INC(PADRE^.CANTIDADHIJOS);
	PADRE^.HIJOS[PADRE^.CANTIDADHIJOS]:=HIJO;
END;


PROCEDURE NHIJO (VAR PADRE:PARBOL;N:BYTE;VAR HIJO:PARBOL);
BEGIN
	HIJO:=PADRE^.HIJOS[N]
END;


FUNCTION CANTIDADEHIJOS(VAR PADRE:PARBOL):BYTE;
BEGIN
	CANTIDADEHIJOS:=PADRE^.CANTIDADHIJOS;
END;


PROCEDURE BORRARARBOL(VAR ARBOL:PARBOL);
VAR 
	I:BYTE;
BEGIN
	IF ARBOL<>NIL THEN
 BEGIN
		FOR I:=1 TO ARBOL^.CANTIDADHIJOS DO
		BEGIN
			BORRARARBOL(ARBOL^.HIJOS[I])
		END;
	DISPOSE(ARBOL);
 END;
END;


PROCEDURE MOSTRAR(VAR ARBOL:PARBOL;D:INTEGER);
VAR 
	HIJO:PARBOL; I:BYTE;
BEGIN
	WRITELN('':D,NVOT[ARBOL^.VOT],'-',ARBOL^.LEXEMA);
	FOR I:=1 TO ARBOL^.CANTIDADHIJOS DO
	BEGIN
		NHIJO(ARBOL,I,HIJO);
		MOSTRAR(HIJO,D+2);
   END;
END;


PROCEDURE CARGARFUNCIONES(VAR LF:LFs;LEXEMA:STRING;APUNTADOR:PARBOL;VAR I:BYTE);
BEGIN
	INC(I);
	LF.INFO[I].LEXEMA:=LEXEMA;
	LF.INFO[I].APUNTADOR:=APUNTADOR;
END;


PROCEDURE PILAA;
VAR 
	ESTADO:STRING[6];
	ATERMINAL:TERMINALES;
	PILA:PILAT;
	LF:LFs;
	ELEMENTO:VARIABLESTERMINALES;
	TASI:TAS;
	AUX1,LEXEMA,PALABRA:STRING;
	Control:longint;
	Fuente:tfuente;
	I:INTEGER;
	RAIZ:PARBOL;
	ARBOL:PARBOL;
	PELEMENTO:PARBOL;    //NODO PADRE
	L:LISTA;
	PROD:ARRAY[1..MAXP] OF VARIABLESTERMINALES;
	CPROD:BYTE;
 APUNTADOR:PARBOL;
 RUTA:STRING;
BEGIN
    writeln('INGRESE RUTA DEL ARCHIVO');
    READLN(RUTA);
	Assign(Fuente,RUTA);
	Reset(Fuente);
	CrearLista(L);
	CREARPILA(PILA);
	CREARNODO(ARBOL,PROGRAMA,'');
	RAIZ:=ARBOL;
	INICIALIZARMATRIZ(TASI);
	CARGARM(TASI);
	APILAR(PILA,PESOS,NIL);
	APILAR(PILA,PROGRAMA,ARBOL);
	ESTADO:='';
	palabra:='';
	CONTROL:=0;
	LF.TAM:=0;
	SigComplex(Fuente,Control,ATERMINAL,Lexema,L);
	while (estado<>'ERROR1')AND(estado<>'ERROR2') and (estado<>'EXITO') AND (ATERMINAL<>ERRORLEXICO) DO
	begin
		DESAPILAR(PILA,ELEMENTO,PELEMENTO);
         IF ELEMENTO=FUCTION THEN
         APUNTADOR:=PELEMENTO;

		IF ELEMENTO IN [ID..HASTA] THEN
		BEGIN
			IF ELEMENTO=ATERMINAL THEN	
			BEGIN
				PELEMENTO^.LEXEMA:=LEXEMA;
				IF PELEMENTO^.VOT = ID THEN
                IF ARBOL^.VOT=FUNCION THEN
					BEGIN
						CARGARFUNCIONES(LF,LEXEMA,APUNTADOR,LF.TAM);
					END;
				SigComplex(Fuente,Control,ATERMINAL,Lexema,L);
				END
				ELSE
				ESTADO:='ERROR1';
			END
			ELSE IF ELEMENTO IN [PROGRAMA..BLOQUE] THEN
			BEGIN
				IF TASI[ELEMENTO,ATERMINAL]='' THEN
				BEGIN
					ESTADO:='ERROR2';
				END
				ELSE
				BEGIN
					AUX1:=TASI[ELEMENTO,ATERMINAL];
					CPROD:=0;
					FOR I:=1 TO LENGTH(AUX1)+1 DO
					BEGIN
						IF (AUX1[I]<>#32) AND (I<=LENGTH(AUX1)) THEN
							PALABRA:=PALABRA+AUX1[I]
						ELSE
						BEGIN
							ELEMENTO:=CAMBIO(PALABRA);
							IF ELEMENTO<>EPSILON  THEN
							BEGIN
								INC(CPROD);
								PROD[CPROD]:=ELEMENTO;
							END;
							PALABRA:='';
						END;
					END;
					FOR I:=CPROD DOWNTO 1 DO
					BEGIN
						CREARNODO(ARBOL,PROD[I],'');
						AGREGARHIJO(PELEMENTO,ARBOL);
					END;
					FOR I:=CPROD DOWNTO 1 DO
					BEGIN
						NHIJO(PELEMENTO,I,ARBOL);
						APILAR(PILA,ARBOL^.VOT,ARBOL);
					END;
			END;
		END
	ELSE IF (ELEMENTO=ATERMINAL) AND (ATERMINAL=PESOS) THEN
			ESTADO:='EXITO';
end;


//MOSTRAR(RAIZ,0);    MUESTRA ARBOL

LAPRIMERA(RAIZ,L,LF);
WRITELN(ESTADO);
READKEY;
close(fuente);
END;

end.
